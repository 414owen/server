call mtr.add_suppression("Can.t init tc log");
call mtr.add_suppression("Aborting");
call mtr.add_suppression("Found.*prepared [XA ]*transaction[s]*");
SET @@global.max_binlog_size= 4096;
SET @@global.sync_binlog= 1;
RESET MASTER;
FLUSH LOGS;
CREATE TABLE ti (a INT PRIMARY KEY, b MEDIUMTEXT) ENGINE=Innodb;
CREATE PROCEDURE sp_xa()
BEGIN
XA START   'xid';
INSERT INTO ti VALUES (2, REPEAT("x", 4100));
XA END     'xid';
XA PREPARE 'xid';
END|
# case A. binlog input p1,g2,g3: p1 gets truncated along with g2,g3
connect master1,localhost,root,,;
"List of binary logs before rotation"
show binary logs;
Log_name	File_size
master-bin.000001	#
master-bin.000002	#
INSERT INTO ti VALUES(1,"I am gonna survive");
SET DEBUG_SYNC= "commit_after_release_LOCK_after_binlog_sync SIGNAL master1_ready WAIT_FOR master1_go_never_arrives";
call sp_xa();
connect master2,localhost,root,,;
SET DEBUG_SYNC= "now WAIT_FOR master1_ready";
SET DEBUG_SYNC= "commit_before_get_LOCK_commit_ordered SIGNAL master2_ready WAIT_FOR master2_go_never_arrives";
INSERT INTO ti VALUES (3, "not gonna survive");
connection default;
SET DEBUG_SYNC= "now WAIT_FOR master2_ready";
connect master3,localhost,root,,;
SET DEBUG_SYNC= "ha_commit_trans_before_log_and_order SIGNAL master3_ready WAIT_FOR master3_go_never_arrives";
INSERT INTO ti VALUES (4, "not gonna be logged therefore survive"),(5, "ditto");
connection default;
SET DEBUG_SYNC= "now WAIT_FOR master3_ready";
"List of binary logs before crash"
show binary logs;
Log_name	File_size
master-bin.000001	#
master-bin.000002	#
master-bin.000003	#
# The gtid binlog state prior the crash will be truncated at the end of the test
SELECT @@global.gtid_binlog_state;
@@global.gtid_binlog_state
0-1-5
connection default;
# Kill the server
disconnect master1;
disconnect master2;
disconnect master3;
# restart: --rpl-semi-sync-slave-enabled=1 --sync-binlog=1 --log-warnings=3
FOUND 1 /Successfully truncated.*to remove transactions starting from GTID 0-1-4/ in mysqld.1.err
FOUND 1 /truncated binlog file:.*master.*000002/ in mysqld.1.err
# One record should be present in table
SELECT * FROM ti;
a	b
1	I am gonna survive
# The truncated gtid binlog state
SELECT @@global.gtid_binlog_state;
@@global.gtid_binlog_state
0-1-3
SELECT @@global.gtid_binlog_pos;
@@global.gtid_binlog_pos
0-1-3
DELETE FROM ti;
# case B. binlog input g1,p2,g3: p2 gets truncated along with g1,g3
connect master1,localhost,root,,;
"List of binary logs before rotation"
show binary logs;
Log_name	File_size
master-bin.000001	#
master-bin.000002	#
master-bin.000003	#
INSERT INTO ti VALUES(1,"I am gonna survive");
SET DEBUG_SYNC= "commit_after_release_LOCK_after_binlog_sync SIGNAL master1_ready WAIT_FOR master1_go_never_arrives";
INSERT INTO ti VALUES (3, "not gonna survive");
connect master2,localhost,root,,;
SET DEBUG_SYNC= "now WAIT_FOR master1_ready";
SET DEBUG_SYNC= "commit_before_get_LOCK_commit_ordered SIGNAL master2_ready WAIT_FOR master2_go_never_arrives";
call sp_xa();
connection default;
SET DEBUG_SYNC= "now WAIT_FOR master2_ready";
connect master3,localhost,root,,;
SET DEBUG_SYNC= "ha_commit_trans_before_log_and_order SIGNAL master3_ready WAIT_FOR master3_go_never_arrives";
INSERT INTO ti VALUES (4, "not gonna be logged therefore survive"),(5, "ditto");
connection default;
SET DEBUG_SYNC= "now WAIT_FOR master3_ready";
"List of binary logs before crash"
show binary logs;
Log_name	File_size
master-bin.000001	#
master-bin.000002	#
master-bin.000003	#
# The gtid binlog state prior the crash will be truncated at the end of the test
SELECT @@global.gtid_binlog_state;
@@global.gtid_binlog_state
0-1-7
connection default;
# Kill the server
disconnect master1;
disconnect master2;
disconnect master3;
# restart: --rpl-semi-sync-slave-enabled=1 --sync-binlog=1 --log-warnings=3
FOUND 1 /Successfully truncated.*to remove transactions starting from GTID 0-1-6/ in mysqld.1.err
FOUND 1 /truncated binlog file:.*master.*000003/ in mysqld.1.err
# One record should be present in table
SELECT * FROM ti;
a	b
1	I am gonna survive
# The truncated gtid binlog state
SELECT @@global.gtid_binlog_state;
@@global.gtid_binlog_state
0-1-5
SELECT @@global.gtid_binlog_pos;
@@global.gtid_binlog_pos
0-1-5
DELETE FROM ti;
# case C. binlog input G1,P2,G3: P2 remains prepared.
connect master1,localhost,root,,;
INSERT INTO ti VALUES(1,"I am gonna survive");
connect master2,localhost,root,,;
call sp_xa();
connect master3,localhost,root,,;
INSERT INTO ti VALUES(3,"Me too");
connection default;
# restart: --rpl-semi-sync-slave-enabled=1 --sync-binlog=1 --log-warnings=3
disconnect master1;
disconnect master2;
disconnect master3;
# restart: --rpl-semi-sync-slave-enabled=1 --sync-binlog=1 --log-warnings=3
# xid must be in
XA RECOVER;
formatID	gtrid_length	bqual_length	data
1	3	0	xid
# case D. prove Binlog-checkpoint based recovery for XA-"complete"
XA COMMIT 'xid';
FLUSH LOGS;
# Kill the server
# restart: --rpl-semi-sync-slave-enabled=1 --sync-binlog=1 --log-warnings=3
# no xid must be in
XA RECOVER;
formatID	gtrid_length	bqual_length	data
SELECT count(*) = 3 FROM ti;
count(*) = 3
1
SELECT @@global.gtid_binlog_state;
@@global.gtid_binlog_state
0-1-10
SELECT @@global.gtid_binlog_pos;
@@global.gtid_binlog_pos
0-1-10
# Cleanup
DROP PROCEDURE sp_xa;
DROP TABLE ti;
SET @@global.sync_binlog= default;
# End of the tests
