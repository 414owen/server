# ==== Purpose ====
#
# Test verifies the truncation of single binary log file.
#
# ==== References ====
#
# MDEV-21117: recovery for --rpl-semi-sync-slave-enabled server
# MDEV-33168 XA crash-recovery base on engines prepare first rule

--source include/have_innodb.inc
--source include/have_aria.inc
# File: binlog_truncate_active_log.inc included in test makes use of
#       'debug_sync' facility.
--source include/have_debug_sync.inc
--source include/have_binlog_format_statement.inc

call mtr.add_suppression("Can.t init tc log");
call mtr.add_suppression("Aborting");
call mtr.add_suppression("Found.*prepared [XA ]*transaction[s]*");

# The following cases are tested:
# A. 2pc transaction is followed by a blank "zero-engines" one
# B. 2pc transaction follows the blank one
# C. Similarly to A, with the XA blank transaction
#
# D-G verify MDEV-33168.

RESET MASTER;
SET @@global.sync_binlog=1;
CREATE TABLE t (f INT) ENGINE=INNODB;
CREATE TABLE t2 (f INT) ENGINE=INNODB;
CREATE TABLE t4 (f INT) ENGINE=INNODB;
CREATE TABLE tm (f INT) ENGINE=Aria;

# Old (pre-crash) binlog file index initial value.
# It keeps incremented at the end of each case.
--let $binlog_file_index=1
# parameter to binlog_truncate_active_log.inc
--let $delete=1

--echo # Case A.
# Using 'debug_sync' hold 'query1' execution after 'query1' is flushed and
# synced to binary log but not yet committed. In an another connection hold
# 'query2' execution after 'query2' is flushed and synced to binlog.
# Crash and restart server with --rpl-semi-sync-slave-enabled=1
#
# During recovery of binary log 'query1' status is checked with InnoDB engine,
# it will be in prepared but not yet commited. All transactions starting from
# 'query1' onwards will be removed from the binary log.
# Show-binlog-events is to prove that.

--let $truncate_gtid_pos = 0-1-7
--let $query1 = INSERT INTO t VALUES (20)
--let $query2 = DELETE FROM t2 WHERE f = 0 /* no such record */
--source binlog_truncate_active_log.inc

--echo # Case B.
# The inverted sequence ends up to truncate starting from $query2
--let $truncate_gtid_pos = 0-1-11
--let $query1 = DELETE FROM t2 WHERE f = 0
--let $query2 = INSERT INTO t VALUES (20)
--source binlog_truncate_active_log.inc


--echo # Case C.
delimiter |;
CREATE PROCEDURE sp_blank_xa()
BEGIN
 XA START   'blank';
 DELETE FROM t2 WHERE f = 0 /* no such record */;
 XA END     'blank';
 XA PREPARE 'blank';
END|
delimiter ;|

# The same as in A with $query2 being the zero-engine XA transaction.
# Both $query1 and $query2 are going to be truncated.
--let $truncate_gtid_pos = 0-1-15
--let $query1 = INSERT INTO t VALUES (20)
--let $query2 = CALL sp_blank_xa
--source binlog_truncate_active_log.inc

DROP PROCEDURE sp_blank_xa;


--echo # Case D.
delimiter |;
CREATE PROCEDURE sp_xa()
BEGIN
 XA START   'xid';
 DELETE FROM t WHERE f = 10;
 XA END     'xid';
 XA PREPARE 'xid';
END|
delimiter ;|

# $query1 being the prepared XA transaction.
# Truncation must occurs at $query1 because $query2 is not going to commit
# therefore at recovery it will be in-doubt and thus be rolled back by
#  --rpl-semi-sync-slave-enabled=1. As $query2 could not be proved
# as acknowlegded by slave, $query1 has to be pessimistically regarded the same.
--let $truncate_gtid_pos = 0-1-20
--let $query1 = CALL sp_xa
--let $query2 = INSERT INTO t2 VALUES (20)
--source binlog_truncate_active_log.inc
# Proof:
--echo # no 'xid' in
XA RECOVER;
SELECT count(*) > 0 as "because of rolled back" FROM t WHERE f = 10;

--echo # Case E.
# The same as D, but XAP of $query1 survives the crash-recovery thanks to
# $query20 is going to durably commit prior to the crash.

--let $truncate_gtid_pos = 0-1-2[1-4]
--let $query1 = CALL sp_xa
let $query2 =;
--let $query20 = INSERT INTO t2 VALUES (20)
--let $delete=0
--let $no_truncate=1
--source binlog_truncate_active_log.inc
# Proof:
--echo # 'xid' exists in
XA RECOVER;

# restore to the default
let $query20 =;
--let $no_truncate=0

--echo # Case F.
# Recovery of XA-ROLLBACK. The conditions are like in D. The outcome
# is truncation of both $query1,2.
# Therefore `xid` must remain in prepared state.
--let $truncate_gtid_pos = 0-1-27

--let $query1 = XA ROLLBACK 'xid';
--let $query2 = INSERT INTO t2 VALUES (30)
--let $delete=0
--source binlog_truncate_active_log.inc

# Proof:
--echo # 'xid' exists in
XA RECOVER;

--echo # Case G.
# Recovery of XA-COMMIT. The conditions are like in F. The outcome
# is truncation of both $query1,2.
# Therefore `xid` must remain in prepared state.
--let $truncate_gtid_pos = 0-1-29

--let $query1 = XA COMMIT 'xid';
--let $query2 = INSERT INTO t2 VALUES (30)
--let $delete=0
--source binlog_truncate_active_log.inc

# Proof:
--echo # 'xid' exists in
XA RECOVER;

XA COMMIT 'xid';
DROP PROCEDURE sp_xa;

--echo # Cleanup
DROP TABLE t,t2,tm;
SET @@global.sync_binlog= default;
--echo # End of the tests
