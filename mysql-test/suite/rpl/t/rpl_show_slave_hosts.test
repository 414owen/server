###############################################################################
# Bug#13963 SHOW SLAVE HOSTS is unreliable
#
# Slaves only appear in the output of SHOW SLAVE HOSTS when report-host option
# is set. If an expected slave does not appear in the list, nobody knows
# whether the slave does not connect or has started without the "report-host"
# option.
#
# Remove the "Rpl_recovery_rank" column from SHOW SLAVE HOSTS, It is not
# implemented.
#######################################################################
source include/master-slave.inc;
connect (slave2,127.0.0.1,root,,test,$SLAVE_MYPORT2,);

connection slave2;
RESET SLAVE;
--replace_result $MASTER_MYPORT MASTER_PORT
--eval CHANGE MASTER TO master_host='127.0.0.1',master_port=$MASTER_MYPORT,master_user='root'
START SLAVE IO_THREAD;
source include/wait_for_slave_io_to_start.inc;

connection master;
let $show_statement= SHOW SLAVE HOSTS;
let $field= Server_id;
# 3 is server_id of slave2.
let $condition= ='3';
source include/wait_show_condition.inc;
# Make sure that the other slave also had time to register. Otherwise we get
# occasional spurious failures where server_id=2 is missing from SHOW SLAVE
# HOSTS, when that slave is much slower to register due to thread scheduling.
let $condition= ='2';
source include/wait_show_condition.inc;
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;

connection slave2;
--source include/stop_slave_io.inc

connection master;
let $show_statement= SHOW SLAVE HOSTS;
let $field= Server_id;
# 3 is server_id of slave2.
let $condition= <> '3';
# All rows of 'SHOW SLAVE HOSTS' are not equal to 3.  It mean that master has
# knew the leave of slave2 and has unregistered it.
let $wait_for_all= 1;
source include/wait_show_condition.inc;
--replace_result $SLAVE_MYPORT SLAVE_PORT
SHOW SLAVE HOSTS;


--echo #
--echo # MDEV-21322: report slave progress to the primary
--echo #

call mtr.add_suppression('Slave I/O: Relay log write failure: could not queue event from master');
call mtr.add_suppression('Replication event checksum verification failed');
call mtr.add_suppression("Timeout waiting for reply of binlog*");
call mtr.add_suppression('Found invalid event in binary log');
call mtr.add_suppression('event read from binlog did not pass crc check');
call mtr.add_suppression('Event crc check failed! Most likely there is event corruption');
call mtr.add_suppression('Slave SQL: Error initializing relay log position: I/O error reading event at position .*, error.* 1593');
call mtr.add_suppression("Semi-sync slave .* reply");

select @@global.rpl_semi_sync_master_wait_point;
reset master;

--echo # Test 1: Primary has not enabled semisync
--echo # Note:   even if not enabled semisync we are expecting to see following
--echo #         columns:
--echo #         `Server_id`,`Host Port`,`Master_id`,`Gtid_State_Sent`,`Gtid_State_Ack`,`Replica_type`(TODO),
--echo #         where replica with `server_id=2` is already connected
--echo # -----------------------------------------------------------------------
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;

--echo # Test 2: Primary enabled semisync
--echo # Note:   it should be the same as test 1
--echo # -----------------------------------------------------------------------
set global rpl_semi_sync_master_enabled = 1;
show variables like 'rpl_semi_sync_master_enabled';
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;


--echo # Test 3: Replica (server_id=2) enabled semisync
--echo # Note:   No new GTIDs, so expected empty `Gtid_State_Sent`,`Gtid_State_Ack`
--echo # -----------------------------------------------------------------------
connection slave;
--source include/stop_slave.inc
--source include/reset_slave.inc
set global rpl_semi_sync_slave_enabled = 1;
--source include/start_slave.inc
show variables like 'rpl_semi_sync_slave_enabled';
# Check on replica number of ACKs
show status like "Rpl_semi_sync_slave_send_ack";

connection master;
let $status_var= Rpl_semi_sync_master_clients;
let $status_var_value= 1;
source include/wait_for_status_var.inc;
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;


--echo # Test 4: Make new events - generate new GTID
--echo # Note 1: Create 2 events on primary. Replica is already connected
--echo # Note 2: `Gtid_State_Sent` and `Gtid_State_Ack` should have event group
--echo # -----------------------------------------------------------------------
create table t(t int);
insert into t values (1);

show status like 'Rpl_semi_sync_master_status';
show status like 'Rpl_semi_sync_master_clients';
show status like 'Rpl_semi_sync_master_no_tx';
# There are 2 events
show status like 'Rpl_semi_sync_master_yes_tx';
# Here we should get `Gtid_State_Sent` and `Gtid_State_Ack`
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;
show status like 'rpl_semi_sync_master%';

connection slave;
# Check on replica number of ACKs
show status like "Rpl_semi_sync_slave_send_ack";

--echo # Test 5: Enable semi-sync for slave2
--echo # Note 1: Replica (`server_id=3`) should be started and semi-sync enabled
--echo # Note 2: In semi-sync replication ACK thread (on primary),
--echo #         waits only on single replica to respond about received events.
--echo # Note 3: Since `Gtid_State_Ack` is received for 2 events
--echo #         from `server_id=2` in previous test and there is no new event
--echo #         in this test, primary is resending old transactions,
--echo #         we are expecting empty `Gtid_State_Ack` for `server_id=3`
--echo #         in show statement (see Note 2).
--echo # -----------------------------------------------------------------------
# Replica is already stopped
connection slave2;
set global rpl_semi_sync_slave_enabled = 1;
--source include/start_slave.inc
show variables like 'rpl_semi_sync_slave_enabled';
show status like "Rpl_semi_sync_slave_send_ack";

connection master;
# - Check number of semi-sync replicas - 2 should be connected
let $status_var= Rpl_semi_sync_master_clients;
let $status_var_value= 2;
source include/wait_for_status_var.inc;
show status like 'Rpl_semi_sync_master_clients';
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

--echo # Test 6: Create new transactions on primary
--echo # Note:   New transactions on primary are sent to replicas
--echo #         and connected replicas (`server_id=2` and `server_id=3`)
--echo #         should sync to the GTID state on primary.
--echo # -----------------------------------------------------------------------
# Check old counters for _get_ack and _request_ack on primary
show status like 'Rpl_semi_sync_master_request_ack';
show status like 'Rpl_semi_sync_master_get_ack';

# Create 2 new events
create table t2(t2 int);
insert into t2 values (2);

# Check number of received transactions (it should be 4)
show status like 'Rpl_semi_sync_master_no_tx';
let $status_var= Rpl_semi_sync_master_yes_tx;
let $status_var_value= 4;
source include/wait_for_status_var.inc;
show status like 'Rpl_semi_sync_master_yes_tx';
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;
# Determine binlog_dump_thread_count, number of connected semi-sync replica
show status like "Slaves_connected";
# Here we should get for 2 replicas and 2 events increment by 4 for `Rpl_semi_sync_master_get_ack`,
# while increment by 2 is expected for `Rpl_semi_sync_master_request_ack` and this is what we get
show status like 'Rpl_semi_sync_master_request_ack';
show status like 'Rpl_semi_sync_master_get_ack';

# Check ACKs on slave2
connection slave2;
show status like "Rpl_semi_sync_slave_send_ack";

--echo # Test 7: Simulate stop of the IO thread of replica
--echo # Note 1: Stopping the IO thread will unregister replica from master info
--echo #         so for `server_id=2`, `rpl_semi_sync_slave_status` will be `OFF`
--echo #         and so should not be visible in show statement output.
--echo # Note 2: New event will be created and successfully sent and acked by `server_id=3`
--echo # Note 3: Starting the IO thread again for `server_id=2` will enable `rpl_semi_sync_slave_status`,
--echo #         but since there is no new transaction and `ack` counter is reseted,
--echo #         `Gtid_State_Sent` and `Gtid_State_Ack` will be empty.
--echo # Note 4: When synching replica with primary, primary will resent the old
--echo #         transaction, so `Gtid_State_Sent` will be the same event group
--echo #         as `server_id=3`(replica that ACKed the transaction), but since
--echo #         there is no new transaction on primary `Gtid_State_Ack` will
--echo #         remain empty.
--echo # -----------------------------------------------------------------------
connection slave;
let $status_var= rpl_semi_sync_slave_status;
let $status_var_value= ON;
source include/wait_for_status_var.inc;
show status like 'rpl_semi_sync_slave%';
show variables like 'rpl_semi_sync_slave_enabled';

STOP SLAVE IO_THREAD;
--source include/wait_for_slave_io_to_stop.inc

let $status_var= rpl_semi_sync_slave_status;
let $status_var_value= OFF;
source include/wait_for_status_var.inc;
show status like 'rpl_semi_sync_slave%';
show variables like 'rpl_semi_sync_slave_enabled';

connection master;
# Note without waiting that master [un]registers replica, multiple rows (cached) for 
# the same replica may be showed in show replica hosts statement. So use `Slaves_connected`.
# `Rpl_semi_sync_master_clients` can not be trusted compared to previous status check.
let $status_var= Slaves_connected;
let $status_var_value= 1;
source include/wait_for_status_var.inc;
show status like "Slaves_connected";

--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

INSERT INTO t VALUES (10);
show status like 'Rpl_semi_sync_master_yes_tx';
let $status_var= Rpl_semi_sync_master_yes_tx;
let $status_var_value= 5;
source include/wait_for_status_var.inc;
let $status_var= Rpl_semi_sync_master_get_ack;
let $status_var_value= 7;
source include/wait_for_status_var.inc;
let $status_var= Rpl_semi_sync_master_request_ack;
let $status_var_value= 5;
source include/wait_for_status_var.inc;
show status like 'Rpl_semi_sync_master_request_ack';
show status like 'Rpl_semi_sync_master_get_ack';

--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

connection slave;
START SLAVE IO_THREAD;
--source include/wait_for_slave_io_to_start.inc
let $status_var= rpl_semi_sync_slave_status;
let $status_var_value= ON;
source include/wait_for_status_var.inc;
show status like 'rpl_semi_sync_slave%';
show variables like 'rpl_semi_sync_slave_enabled';

connection master;
let $status_var= Slaves_connected;
let $status_var_value= 2;
source include/wait_for_status_var.inc;
show status like "Slaves_connected";
show status like 'Rpl_semi_sync_master_clients';
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

--echo "Sync replica with master"
sync_slave_with_master;
show status like 'rpl_semi_sync_slave%';

connection master;
show status like 'Rpl_semi_sync_master_clients';
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;
show status like "Slaves_connected";
# Get ACK and request ACK should be the same as before
show status like 'Rpl_semi_sync_master_request_ack';
show status like 'Rpl_semi_sync_master_get_ack';

--echo # Test 8: Replica `server_id=2` failure with `corrupt_queue_event`
--echo # Note 1: Simulate replicas failure by making replica busy.
--echo #         Consequence is that replica will be unregistered and that is why
--echo #         we need to wait that replica unregisters (`Slaves_connected`).
--echo #         By creating new event, only active replicas should respond
--echo #         (`server_id=3`) with ACK
--echo # Note 2: In order not to show old result from `server_id=2`,from busy replica
--echo #         we have to *wait* that binlog_dump_thread_count shows status 
--echo #         `Slaves_connected` decreased and after that check show statement.
--echo # -----------------------------------------------------------------------
connection slave;
--let $sav_server_2_dbug= `SELECT @@GLOBAL.debug_dbug`
SET @@GLOBAL.debug_dbug= "+d,corrupt_queue_event";

connection master;
INSERT INTO t VALUES (3);
let $status_var= Rpl_semi_sync_master_yes_tx;
let $status_var_value= 6;
source include/wait_for_status_var.inc;
show status like 'Rpl_semi_sync_master_yes_tx';

let $status_var= Slaves_connected;
let $status_var_value= 1;
source include/wait_for_status_var.inc;
show status like "Slaves_connected";
let $status_var= Rpl_semi_sync_master_clients;

let $status_var= Rpl_semi_sync_master_get_ack;
let $status_var_value= 8;
source include/wait_for_status_var.inc;
let $status_var= Rpl_semi_sync_master_request_ack;
let $status_var_value= 6;
source include/wait_for_status_var.inc;
show status like 'Rpl_semi_sync_master_request_ack';
show status like 'Rpl_semi_sync_master_get_ack';

--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

connection slave;
--eval SET @@GLOBAL.debug_dbug= "$sav_server_2_dbug"

connection master;
let $status_var= Slaves_connected;
# Setting the old value for debug_dbug will not start the slave
let $status_var_value= 1;
source include/wait_for_status_var.inc;
show status like "Slaves_connected";
show status like 'Rpl_semi_sync_master_clients';
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

--echo # Test 9: Stop `server_id=3`
--echo # Note:   Check that no replicas get new generated event, so show statement
--echo #         is expected to be empty.
--echo # -----------------------------------------------------------------------
connection slave2;
--source include/stop_slave.inc
--source include/reset_slave.inc

connection master;
let $status_var= Slaves_connected;
let $status_var_value= 0;
source include/wait_for_status_var.inc;
show status like "Slaves_connected";
source include/wait_for_status_var.inc;
# get_ack and request_ack stay the same
let $status_var= Rpl_semi_sync_master_get_ack;
let $status_var_value= 8;
source include/wait_for_status_var.inc;
let $status_var= Rpl_semi_sync_master_request_ack;
let $status_var_value= 6;
source include/wait_for_status_var.inc;
show status like 'Rpl_semi_sync_master_no_tx';
show status like 'Rpl_semi_sync_master_yes_tx';
show status like 'Rpl_semi_sync_master_clients';
show status like 'rpl_semi_sync_master_get_ack';
show status like 'Rpl_semi_sync_master_request_ack';
show status like 'Rpl_semi_sync_master_status';
INSERT INTO t VALUES (5);

# If there is new event without semi-sync replicas, master status is disabled
# because commit acknowledgment has not occured
let $status_var= Rpl_semi_sync_master_status;
let $status_var_value= OFF;
source include/wait_for_status_var.inc;
show status like 'Rpl_semi_sync_master_status';
show status like 'Rpl_semi_sync_master_no_tx';
show status like 'Rpl_semi_sync_master_yes_tx';
show status like 'rpl_semi_sync_master_get_ack';

--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

--echo # Start slaves again
connection slave;
--source include/start_slave.inc
let $status_var= rpl_semi_sync_slave_status;
let $status_var_value= ON;
source include/wait_for_status_var.inc;
show status like 'rpl_semi_sync_slave%';
--sync_with_master

connection slave2;
--source include/start_slave.inc
let $status_var= rpl_semi_sync_slave_status;
let $status_var_value= ON;
source include/wait_for_status_var.inc;
show status like 'rpl_semi_sync_slave%';
--sync_with_master

--echo # sync with master, should ENABLE master_status, commit acknowledgment will be cleared?
connection master;
let $status_var= Rpl_semi_sync_master_status;
let $status_var_value= ON;
source include/wait_for_status_var.inc;
show status like 'Rpl_semi_sync_master_status';
show status like 'Rpl_semi_sync_master_no_tx';
show status like 'Rpl_semi_sync_master_yes_tx';
show status like 'rpl_semi_sync_master_get_ack';

--echo # Test 10: Testing `rpl_semi_sync_master_timeout=0`
--echo # Note 1:  For asynchronous replication `Gtid_state_sent` is not null,
--echo #          but `Gtid_state_ack` is null.
--echo # Note 2:  We want that `rpl_semi_sync_master_timeout=0` be edge case,
--echo #          by mimicking asynchronous replication, as semi-sync stalled
--echo #          replication type, for which `Gtid_state_ack` should not update
--echo #          or be null (see Note 3). Also `rpl_semi_sync_master_status` has
--echo #          to remain `ON`, instead switching off, so instead of
--echo #          no waiting on ACK, primary must wait on ACK from replica.
--echo # Note 3:  With this option we want `Gtid_state_ack` to reflect
--echo #          the latest received transaction by the replica[s].
--echo # -----------------------------------------------------------------------
# Test DBUG_SYNC by stopping the slave and testing the new sync point
# Note we need to stop both slaves in order to control sent ACK for new active transaction

--let $save_default_master_timeout= `SELECT @@GLOBAL.rpl_semi_sync_master_timeout`
select @@global.rpl_semi_sync_master_timeout;
show variables like 'rpl_semi_sync_master_enabled';

# Master status must be `ON`
let $status_var= rpl_semi_sync_master_status;
let $status_var_value= ON;
source include/wait_for_status_var.inc;
show status like 'rpl_semi_sync_master_status';

show status like 'rpl_semi_sync_master_get_ack';
set global rpl_semi_sync_master_timeout=0;
select @@global.rpl_semi_sync_master_timeout;
# here rpl_semi_sync_master_status=0 means async is taking place (no wait on ACK from slave)
show variables like 'rpl_semi_sync_master_timeout';
show status like 'rpl_semi_sync_master_status';

connection slave;
--source include/stop_slave.inc
--let $save_server_2_dbug= `SELECT @@GLOBAL.DEBUG_DBUG`
SET @@GLOBAL.DEBUG_DBUG="d,synchronize_semisync_slave_reply";
--source include/start_slave.inc
let $status_var= rpl_semi_sync_slave_status;
let $status_var_value= ON;
source include/wait_for_status_var.inc;
show status like 'rpl_semi_sync_slave%';
SET debug_sync='now WAIT_FOR at_slave_reply TIMEOUT 10';

connection slave2;
--source include/stop_slave.inc
--let $save_server_3_dbug= `SELECT @@GLOBAL.DEBUG_DBUG`
SET @@GLOBAL.DEBUG_DBUG="d,synchronize_semisync_slave_reply";
--source include/start_slave.inc
let $status_var= rpl_semi_sync_slave_status;
let $status_var_value= ON;
source include/wait_for_status_var.inc;
show status like 'rpl_semi_sync_slave%';
SET debug_sync='now WAIT_FOR at_slave_reply TIMEOUT 10';

--echo # Both replicas are stopped with synchronization point
connection master;
# Write event
INSERT INTO t values (1111);
# There will be no ACK so good enough to check if the same rpl_semi_sync_master_get_ack is observed
let $status_var= rpl_semi_sync_master_get_ack;
let $status_var_value= 9;
source include/wait_for_status_var.inc;
show status like 'rpl_semi_sync_master_get_ack';

# GTID_sent > GTID_ack (ACK is empty)
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

connection slave;
SET debug_sync='now SIGNAL reply_ack_to_master';

--echo # Replica server_2 have sent ACK
connection master;
# GTID_sent == GTID_ack (updated to the latest active transaction)
# This is weird, master is async, why would it "get" ACK?
let $status_var= rpl_semi_sync_master_get_ack;
let $status_var_value= 10;
source include/wait_for_status_var.inc;
show status like 'rpl_semi_sync_master_get_ack';
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

connection slave2;
SET debug_sync='now SIGNAL reply_ack_to_master';

--echo # Replica server_3 sent ACK (it shouldn't increment ACK to master?)
connection master;
# GTID_sent == GTID_ack (already sent by server_id=2) - this is not good, ack master should be 9 instead of 10?
let $status_var= rpl_semi_sync_master_get_ack;
let $status_var_value= 11;
source include/wait_for_status_var.inc;
show status like 'rpl_semi_sync_master_get_ack';
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

connection slave2;
sync_slave_with_master;

--echo # Sync server_3 with master - it should be the same
connection master;
let $status_var= rpl_semi_sync_master_get_ack;
let $status_var_value= 11;
source include/wait_for_status_var.inc;
show status like 'rpl_semi_sync_master_get_ack';
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

--echo # cleanup
--echo # -------------------------------------------
connection master;
--eval SET @@GLOBAL.rpl_semi_sync_master_timeout= $save_default_master_timeout
SET GLOBAL rpl_semi_sync_master_enabled = 0;
drop table t;
drop table t2;
--source include/save_master_gtid.inc
--save_master_pos

connection slave;
--eval SET @@GLOBAL.debug_dbug= "$save_server_2_dbug"
SET debug_sync='RESET';
--source include/stop_slave.inc
--source include/reset_slave.inc
set global rpl_semi_sync_slave_enabled = 0;
--source include/start_slave.inc
show variables like 'rpl_semi_sync_slave_enabled';

connection slave2;
set global rpl_semi_sync_slave_enabled = 0;
--eval SET @@GLOBAL.debug_dbug= "$save_server_3_dbug"
SET debug_sync='RESET';
show variables like 'rpl_semi_sync_slave_enabled';
 --sync_with_master
--source include/stop_slave.inc

# End of tests
--source include/rpl_end.inc
